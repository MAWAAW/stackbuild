#!/bin/bash

# Générateur de backend Spring Boot sécurisé avec JWT

generate_backend() {
    local project_dir=$1
    local project_name=$2
    local auth_enabled=$3
    
    local backend_dir="$project_dir/backend"
    mkdir -p "$backend_dir"
    
    print_info "  Création de la structure Spring Boot..."
    
    create_maven_structure "$backend_dir" "$project_name"
    generate_pom_xml "$backend_dir" "$project_name"
    generate_application_yml "$backend_dir"
    generate_java_classes "$backend_dir" "$project_name" "$auth_enabled"
    generate_spring_dockerfile "$backend_dir"
    generate_backend_env "$backend_dir"
    
    print_success "  Backend Spring Boot généré"
}

create_maven_structure() {
    local backend_dir=$1
    local project_name=$2
    
    local package_path="com/example/$(echo $project_name | tr '-' '_')"
    local src_dir="$backend_dir/src/main/java/$package_path"
    local resources_dir="$backend_dir/src/main/resources"
    local test_dir="$backend_dir/src/test/java/$package_path"
    
    mkdir -p "$src_dir"/{config,controller,model,repository,service,security,dto,exception}
    mkdir -p "$resources_dir"
    mkdir -p "$test_dir"
}

generate_pom_xml() {
    local backend_dir=$1
    local project_name=$2
    
    cat > "$backend_dir/pom.xml" << 'EOF'
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/>
    </parent>
    
    <groupId>com.example</groupId>
    <artifactId>PROJECT_NAME</artifactId>
    <version>1.0.0</version>
    <name>PROJECT_NAME</name>
    <description>Backend API generated by Web Stack CLI</description>
    <packaging>jar</packaging>
    
    <properties>
        <java.version>17</java.version>
        <jjwt.version>0.12.3</jjwt.version>
    </properties>
    
    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        
        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        
        <!-- JWT -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>${jjwt.version}</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        
        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        
        <!-- Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
EOF
    
    sed -i "s/PROJECT_NAME/$project_name/g" "$backend_dir/pom.xml"
}

generate_application_yml() {
    local backend_dir=$1
    
    cat > "$backend_dir/src/main/resources/application.yml" << 'EOF'
spring:
  application:
    name: backend-api
  
  datasource:
    url: ${DATABASE_URL:jdbc:postgresql://localhost:5432/appdb}
    username: ${DATABASE_USERNAME:appuser}
    password: ${DATABASE_PASSWORD:changeme}
    driver-class-name: org.postgresql.Driver
  
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: false
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        format_sql: true

server:
  port: ${PORT:8080}
  error:
    include-message: never
    include-binding-errors: never

# JWT Configuration
jwt:
  secret: ${JWT_SECRET:your-256-bit-secret-key-change-in-production-please}
  expiration: 86400000  # 24 hours in milliseconds

# CORS Configuration
cors:
  allowed-origins: ${CORS_ORIGINS:http://localhost:4200,http://localhost:3000}
  allowed-methods: GET,POST,PUT,DELETE,OPTIONS
  allowed-headers: Authorization,Content-Type
  exposed-headers: Authorization
  allow-credentials: true
  max-age: 3600

# Logging
logging:
  level:
    root: INFO
    com.example: INFO
EOF
}

generate_java_classes() {
    local backend_dir=$1
    local project_name=$2
    local auth_enabled=$3
    
    local package_path="com/example/$(echo $project_name | tr '-' '_')"
    local src_dir="$backend_dir/src/main/java/$package_path"
    local package_name="com.example.$(echo $project_name | tr '-' '_')"
    
    # Application principale
    cat > "$src_dir/Application.java" << EOF
package $package_name;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
EOF
    
    # Configuration CORS
    cat > "$src_dir/config/CorsConfig.java" << EOF
package $package_name.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

import java.util.Arrays;

@Configuration
public class CorsConfig {
    
    @Value("\${cors.allowed-origins}")
    private String[] allowedOrigins;
    
    @Bean
    public CorsFilter corsFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration config = new CorsConfiguration();
        
        config.setAllowCredentials(true);
        config.setAllowedOrigins(Arrays.asList(allowedOrigins));
        config.addAllowedHeader("*");
        config.addAllowedMethod("*");
        
        source.registerCorsConfiguration("/**", config);
        return new CorsFilter(source);
    }
}
EOF
    
    if [ "$auth_enabled" = true ]; then
        generate_auth_classes "$src_dir" "$package_name"
    fi
    
    # Controller de base
    cat > "$src_dir/controller/HealthController.java" << EOF
package $package_name.controller;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api")
public class HealthController {
    
    @GetMapping("/health")
    public ResponseEntity<Map<String, Object>> health() {
        Map<String, Object> response = new HashMap<>();
        response.put("status", "UP");
        response.put("timestamp", LocalDateTime.now());
        response.put("service", "Backend API");
        return ResponseEntity.ok(response);
    }
}
EOF
}

generate_auth_classes() {
    local src_dir=$1
    local package_name=$2
    
    # JWT Utility
    cat > "$src_dir/security/JwtUtil.java" << EOF
package $package_name.security;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

@Component
public class JwtUtil {
    
    @Value("\${jwt.secret}")
    private String secret;
    
    @Value("\${jwt.expiration}")
    private Long expiration;
    
    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }
    
    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }
    
    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }
    
    private Claims extractAllClaims(String token) {
        return Jwts.parser()
                .verifyWith(getSignKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }
    
    private Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }
    
    public String generateToken(UserDetails userDetails) {
        Map<String, Object> claims = new HashMap<>();
        return createToken(claims, userDetails.getUsername());
    }
    
    private String createToken(Map<String, Object> claims, String subject) {
        return Jwts.builder()
                .claims(claims)
                .subject(subject)
                .issuedAt(new Date(System.currentTimeMillis()))
                .expiration(new Date(System.currentTimeMillis() + expiration))
                .signWith(getSignKey())
                .compact();
    }
    
    private SecretKey getSignKey() {
        return Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));
    }
    
    public Boolean validateToken(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
    }
}
EOF
    
    print_success "  Classes d'authentification JWT générées"

    generate_security_config "$src_dir" "$package_name"
    generate_jwt_filter "$src_dir" "$package_name"
    generate_auth_entrypoint "$src_dir" "$package_name"
    generate_user_details_service "$src_dir" "$package_name"
    generate_user_entity "$src_dir" "$package_name"
    generate_role_enum "$src_dir" "$package_name"
    generate_user_repository "$src_dir" "$package_name"
    generate_auth_controller "$src_dir" "$package_name"
}

generate_security_config() {
  local src_dir=$1
  local package_name=$2

  cat > "$src_dir/security/SecurityConfig.java" << EOF
package $package_name.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableMethodSecurity(prePostEnabled = true)
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtFilter;
    private final AuthEntryPoint authEntryPoint;

    public SecurityConfig(JwtAuthenticationFilter jwtFilter,
                          AuthEntryPoint authEntryPoint) {
        this.jwtFilter = jwtFilter;
        this.authEntryPoint = authEntryPoint;
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .cors(cors -> {})
            .sessionManagement(session ->
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            .exceptionHandling(ex ->
                ex.authenticationEntryPoint(authEntryPoint)
            )
            .authorizeHttpRequests(auth -> auth
                .requestMatchers(
                    "/api/health",
                    "/api/auth/**"
                ).permitAll()
                .anyRequest().authenticated()
            );

        http.addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(
            AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}
EOF
}

generate_jwt_filter() {
  local src_dir=$1
  local package_name=$2

  cat > "$src_dir/security/JwtAuthenticationFilter.java" << EOF
package $package_name.security;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtUtil jwtUtil;
    private final UserDetailsServiceImpl userDetailsService;

    public JwtAuthenticationFilter(JwtUtil jwtUtil,
                                   UserDetailsServiceImpl userDetailsService) {
        this.jwtUtil = jwtUtil;
        this.userDetailsService = userDetailsService;
    }

    @Override
    protected void doFilterInternal(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain
    ) throws ServletException, IOException {

        final String authHeader = request.getHeader("Authorization");

        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }

        String jwt = authHeader.substring(7);
        String username = jwtUtil.extractUsername(jwt);

        if (username != null &&
            SecurityContextHolder.getContext().getAuthentication() == null) {

            UserDetails userDetails =
                userDetailsService.loadUserByUsername(username);

            if (jwtUtil.validateToken(jwt, userDetails)) {
                UsernamePasswordAuthenticationToken authToken =
                    new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities()
                    );

                authToken.setDetails(
                    new WebAuthenticationDetailsSource().buildDetails(request)
                );

                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }

        filterChain.doFilter(request, response);
    }
}
EOF
}

generate_auth_entrypoint() {
  local src_dir=$1
  local package_name=$2

  cat > "$src_dir/security/AuthEntryPoint.java" << EOF
package $package_name.security;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;

@Component
public class AuthEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(
            HttpServletRequest request,
            HttpServletResponse response,
            AuthenticationException authException
    ) throws IOException {
        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Unauthorized");
    }
}
EOF
}

generate_user_details_service() {
  local src_dir=$1
  local package_name=$2

  cat > "$src_dir/security/UserDetailsServiceImpl.java" << EOF
package $package_name.security;

import $package_name.model.User;
import $package_name.repository.UserRepository;
import org.springframework.security.core.userdetails.*;
import org.springframework.stereotype.Service;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {

    private final UserRepository userRepository;

    public UserDetailsServiceImpl(UserRepository repo) {
        this.userRepository = repo;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        return org.springframework.security.core.userdetails.User
                .withUsername(user.getUsername())
                .password(user.getPassword())
                .roles(user.getRole().name())
                .build();
    }
}
EOF
}

generate_role_enum() {
cat > "$1/model/Role.java" << EOF
package $2.model;

public enum Role {
    USER,
    ADMIN
}
EOF
}

generate_user_entity() {
cat > "$1/model/User.java" << EOF
package $2.model;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Entity
@Table(name = "users")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String username;

    @Column(nullable = false)
    private String password;

    @Enumerated(EnumType.STRING)
    private Role role;
}
EOF
}

generate_user_repository() {
cat > "$1/repository/UserRepository.java" << EOF
package $2.repository;

import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;
import $2.model.User;

public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
}
EOF
}

generate_auth_controller() {
cat > "$1/controller/AuthController.java" << EOF
package $2.controller;

import $2.security.JwtUtil;
import $2.repository.UserRepository;
import jakarta.validation.Valid;
import lombok.Data;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/auth")
public class AuthController {

    private final UserRepository repo;
    private final PasswordEncoder encoder;
    private final JwtUtil jwt;

    public AuthController(UserRepository repo, PasswordEncoder encoder, JwtUtil jwt) {
        this.repo = repo;
        this.encoder = encoder;
        this.jwt = jwt;
    }

    @PostMapping("/login")
    public String login(@Valid @RequestBody LoginRequest loginRequest) {
        var user = repo.findByUsername(loginRequest.getUsername())
                .orElseThrow(() -> new RuntimeException("Bad credentials"));

        if (!encoder.matches(loginRequest.getPassword(), user.getPassword())) {
            throw new RuntimeException("Bad credentials");
        }

        return jwt.generateToken(
                org.springframework.security.core.userdetails.User
                        .withUsername(user.getUsername())
                        .password(user.getPassword())
                        .roles(user.getRole().name())
                        .build()
        );
    }

    @Data
    static class LoginRequest {
        private String username;
        private String password;
    }
}
EOF
}

generate_spring_dockerfile() {
    local backend_dir=$1
    
    cat > "$backend_dir/Dockerfile" << 'EOF'
FROM maven:3.9-eclipse-temurin-17 AS build

WORKDIR /app

COPY . .

RUN mvn clean package -DskipTests

FROM eclipse-temurin:17-jre-alpine

WORKDIR /app

COPY --from=build /app/target/*.jar app.jar

EXPOSE 8080

ENTRYPOINT ["java", "-jar", "app.jar"]
EOF
}

generate_backend_env() {
    local backend_dir=$1
    
    cat > "$backend_dir/.env.example" << 'EOF'
# Database Configuration
DATABASE_URL=jdbc:postgresql://db:5432/appdb
DATABASE_USERNAME=appuser
DATABASE_PASSWORD=changeme

# JWT Configuration
JWT_SECRET=your-256-bit-secret-key-change-in-production-please

# CORS Configuration
CORS_ORIGINS=http://localhost:4200,http://localhost:3000

# Server Configuration
PORT=8080
EOF
}